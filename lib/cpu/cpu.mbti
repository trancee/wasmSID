package "trancee/wasmSID/lib/cpu"

import(
  "trancee/wasmSID/lib/types"
)

// Values
const CPU_MEM_END : Int = 0xFFFF

const CPU_MEM_SIZE : Int = 0xFFFF

const CPU_MEM_START : Int = 0x0000

fn a(CPU) -> @types.UInt8

fn clear_flags(CPU) -> Unit

fn clear_registers(CPU) -> Unit

fn debug(CPU, Bool) -> Bool

fn get_flags(CPU) -> Flags

fn get_registers(CPU) -> Registers

fn has_interrupt(CPU) -> Bool

fn hook(CPU, Int, (Int) -> Unit) -> Unit

fn interrupts(CPU) -> Bool

fn irq(CPU, pc? : Int) -> Unit

fn load(CPU, @types.UInt16, FixedArray[Byte], length~ : Int = .., has_load_address~ : Bool = ..) -> @types.UInt16

fn nmi(CPU, pc? : Int) -> Unit

fn pc(CPU) -> Int

fn push(CPU, @types.UInt8, dummy~ : Bool = ..) -> Unit

fn push16(CPU, @types.UInt16) -> Unit

fn read(CPU, @types.UInt16, dummy~ : Bool = ..) -> @types.UInt8

fn register(CPU, Register, Int) -> Unit

fn setIRQ(CPU, @types.UInt16) -> Unit

fn setNMI(CPU, @types.UInt16) -> Unit

fn setRESET(CPU, @types.UInt16) -> Unit

fn set_flags(CPU, @types.UInt8) -> Unit

fn set_irq(CPU, state~ : Bool = ..) -> Unit

fn set_nmi(CPU, state~ : Bool = ..) -> Unit

fn set_read(CPU, (Int, Bool) -> Int) -> Unit

fn set_write(CPU, (Int, Int, Bool) -> Unit) -> Unit

fn step(CPU) -> Int

fn write(CPU, @types.UInt16, @types.UInt8, dummy~ : Bool = ..) -> Unit

fn write16(CPU, @types.UInt16, @types.UInt16, dummy~ : Bool = ..) -> Unit

// Types and methods
type AddressHook

pub struct CPU {
  mem : FixedArray[Int]
  mut read : ((Int, Bool) -> Int)?
  mut write : ((Int, Int, Bool) -> Unit)?
  mut cycles : Int
  mut pc : @types.UInt16
  registers : Registers
  flags : Flags
  decimal_mode : Bool
  mut nmi : Bool
  mut irq : Bool
  hooks : Array[AddressHook]
  mut debug : Bool
}
impl CPU {
  a(Self) -> @types.UInt8
  clear_flags(Self) -> Unit
  clear_interrupt(Self) -> Unit
  clear_registers(Self) -> Unit
  debug(Self, Bool) -> Bool
  get_flags(Self) -> Flags
  get_registers(Self) -> Registers
  has_interrupt(Self) -> Bool
  hook(Self, Int, (Int) -> Unit) -> Unit
  interrupts(Self) -> Bool
  irq(Self, pc? : Int) -> Unit
  load(Self, @types.UInt16, FixedArray[Byte], length~ : Int = .., has_load_address~ : Bool = ..) -> @types.UInt16
  new(pc~ : Int = .., decimal_mode~ : Bool = .., debug~ : Bool = ..) -> Self
  nmi(Self, pc? : Int) -> Unit
  pc(Self) -> Int
  push(Self, @types.UInt8, dummy~ : Bool = ..) -> Unit
  push16(Self, @types.UInt16) -> Unit
  read(Self, @types.UInt16, dummy~ : Bool = ..) -> @types.UInt8
  register(Self, Register, Int) -> Unit
  reset(Self, baseaddress? : @types.UInt16) -> Unit
  setIRQ(Self, @types.UInt16) -> Unit
  setNMI(Self, @types.UInt16) -> Unit
  setRESET(Self, @types.UInt16) -> Unit
  set_flags(Self, @types.UInt8) -> Unit
  set_interrupt(Self) -> Unit
  set_irq(Self, state~ : Bool = ..) -> Unit
  set_nmi(Self, state~ : Bool = ..) -> Unit
  set_read(Self, (Int, Bool) -> Int) -> Unit
  set_write(Self, (Int, Int, Bool) -> Unit) -> Unit
  step(Self) -> Int
  write(Self, @types.UInt16, @types.UInt8, dummy~ : Bool = ..) -> Unit
  write16(Self, @types.UInt16, @types.UInt16, dummy~ : Bool = ..) -> Unit
}

pub(all) enum Flag {
  C
  Z
  I
  D
  B
  U
  V
  N
}
impl Flag {
  lor(Self, Self) -> Int
}
impl Eq for Flag

type Flags
impl Flags {
  get(Self) -> @types.UInt8
  set(Self, @types.UInt8) -> Unit
  set_interrupt(Self) -> Unit
}
impl Eq for Flags
impl Show for Flags

pub(all) enum Register {
  SP
  A
  X
  Y
}

pub struct Registers {
  mut sp : @types.UInt8
  mut a : @types.UInt8
  mut x : @types.UInt8
  mut y : @types.UInt8
}
impl Registers {
  new(sp~ : @types.UInt8 = ..) -> Self
  op_get(Self, Register) -> @types.UInt8
  op_set(Self, Register, @types.UInt8) -> Unit
  reset(Self) -> Unit
}

// Type aliases

// Traits

